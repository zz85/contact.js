<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl + jsmpeg</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			overflow: none;
			margin: 0;
		}
	</style>
</head>

<body>

	<div id="stats" style="width:100px; height: 100px;  float: left; position: absolute;"></div>
	<script type="text/javascript" src="vendor/jsmpeg/jsmpeg.min.js"></script>

	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

	<script type="importmap">
			{
				"imports": {
					"three": "/gits/three.js/build/three.module.js"
				}
			}
		</script>

	<script src="src/wire.js"></script>
	<script src="src/connection.js"></script>
	<script src="src/transmitter.js"></script>
	<!-- <script src="src/transmitter_example.js"></script> -->
	<script type="text/javascript">
		var target = 'wss://' + location.hostname + '/touch/touchpad';
		var connection = new Connection(target, handler);
		connection.open();

		// activateTouch();

		var scale = '.75';
		var mode = 'sr';

		function screenshare() {
			mode = 'sr';
			resizeStream();
		}

		function resizeStream() {
			connection.sendType(mode, {
				scale: scale
			});

			// TODO server should broadcast request to resize
			setTimeout(() => {
				player.video.hasSequenceHeader = false
			}, 500);
		}

		function webcam() {
			mode = 'wr';
			resizeStream();
		}

		function setScale(s) {
			scale = s;
			resizeStream();
		}

		function ask() {
			var input = prompt('Say something');
			if (input) connection.sendType('rt', {
				text: input
			})
		}

		function activate(target) {
			target.addEventListener('keydown', (e) => {
				console.log('down', e);
				connection.send('key: ' + e.key + ' code: ' + e.code);
			});

			target.addEventListener('keyup', (e) => {
				console.log('up', e);
			});
		}
	</script>


	<script type="module">
		// var url = 'ws://' + document.location.hostname + ':8082/';
		var url = 'wss://' + document.location.hostname + '/screenshare';
		var started;
		var videoCanvas = document.createElement('canvas');

		var player = new JSMpeg.Player(url, {
			canvas: videoCanvas,
			disableWebAssembly: false,
			audio: false,
			onVideoDecode: function (decoder, elapsedTime) {
				stats.innerHTML = `${(elapsedTime * 1000).toFixed(2)}ms / ${(1 / elapsedTime).toFixed(0)} fps`;

				if (!started) {
					console.log(decoder, videoCanvas.width, videoCanvas.height);
					player.pause();
					started = true;
					init();
					// screenMesh.scale.x = videoCanvas.width / videoCanvas.height;
				}
			},
			// preserveDrawingBuffer: true,
		});
		window.player = player;


		import * as THREE from 'three';

		import { ParametricGeometry } from '/gits/three.js/examples/jsm/geometries/ParametricGeometry.js';
		import { ParametricGeometries } from '/gits/three.js/examples/jsm/geometries/ParametricGeometries.js';
		import { HTMLMesh } from '/gits/three.js/examples/jsm/interactive/HTMLMesh.js';

		import { InteractiveGroup } from '/gits/three.js/examples/jsm/interactive/InteractiveGroup.js';
		import { XRControllerModelFactory } from '/gits/three.js/examples/jsm/webxr/XRControllerModelFactory.js';

		var cube, videoTexture, raycaster;
		const pointer = new THREE.Vector2();

		function init() {
			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0xdddddd)
			scene.fog = new THREE.FogExp2( 0x333333, 0.0025 );
			const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);

			var object3d = new THREE.AmbientLight(0x101010)
			object3d.name = 'Ambient light'
			// object3d.castShadow = true;
			scene.add(object3d)

			var object3d = new THREE.DirectionalLight('white', 0.225)
			object3d.position.set(2.6, 1, 3)
			object3d.position.multiplyScalar(10);
			object3d.name = 'Back light'
			object3d.castShadow = true;
			scene.add(object3d)


			var object3d = new THREE.DirectionalLight('white', 0.375)
			object3d.position.set(-2, -1, 0)
			object3d.position.multiplyScalar(10);
			object3d.name = 'Key light'
			object3d.castShadow = true;
			scene.add(object3d)

			var object3d = new THREE.DirectionalLight('white', 0.75)
			object3d.position.set(3, 3, 2)
			object3d.position.multiplyScalar(10);
			object3d.name = 'Fill light'
			object3d.castShadow = true;
			scene.add(object3d)


			var raycaster = new THREE.Raycaster();
			const renderer = new THREE.WebGLRenderer();
			// renderer.shadowMap.enabled = true;

			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setPixelRatio(window.devicePixelRatio);
			document.body.appendChild(renderer.domElement);

			// const geometry = new THREE.BoxGeometry();
			// const material = new THREE.MeshLambertMaterial({color: 0x44aa88});
			// cube = new THREE.Mesh( geometry, material );
			// scene.add( cube );

			camera.position.z = 5;

			var groundMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
			groundMaterial.color.setHSL(0.6, 0.1, 0.7);
			var plane = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), groundMaterial);
			plane.position.y = - 2;
			plane.rotation.x = - Math.PI / 2;
			plane.receiveShadow = true;
			scene.add(plane);

			// const screenGeometry = new THREE.PlaneGeometry( 1, 1 );

			// var screenGeometry = new ParametricGeometry( ParametricGeometries.plane( 1, 1 ), 10, 10 );

			function curveFunction(u, v, target) {
				const x = u * 1;
				const y = v * 1;

				// could use spline curve here too
				// const z = Math.sin(-u * Math.PI) * 0.2;
				// normalize  between  -0.4, 0.4
				const z = ((u - 0.5)) ** 2 * 0.5;

				target.set(x, y, z);
			}

			var screenGeometry = new ParametricGeometry(curveFunction, 20, 1);

			screenGeometry.center();

			videoTexture = new THREE.CanvasTexture(videoCanvas);
			const materialCanvas = new THREE.MeshBasicMaterial({
				// wireframe: true,
				// color: 0xffffff,
				// doubleSided
				map: videoTexture
			});

			const screenMesh = new THREE.Mesh(screenGeometry, materialCanvas);
			window.screenMesh = screenMesh;
			screenMesh.scale.x = videoCanvas.width / videoCanvas.height;
			screenMesh.scale.multiplyScalar(4);
			screenMesh.rotation.x = -Math.PI / 6;
			screenMesh.castShadow = true;

			scene.add(screenMesh)

			var mouseX = 0.5, mouseY = 0.5;
			window.addEventListener('mousemove', (e) => {
				mouseX = e.clientX / innerWidth;
				mouseY = e.clientY / innerHeight;

				pointer.set(mouseX - 0.5, mouseY - 0.5)
			})

			// const group = new InteractiveGroup( renderer, camera );
			// scene.add( group );

			const mesh = new HTMLMesh( stats );
			mesh.position.x = - 0.75;
			mesh.position.y = 1.5;
			mesh.position.z = - 0.5;
			mesh.rotation.y = Math.PI / 4;
			mesh.scale.setScalar( 2 );
			scene.add( mesh );


			function animate() {
				requestAnimationFrame(animate);

				screenMesh.rotation.x = (mouseY - 0.5) * 0.0;

				// camera.position.y  = -3.5 + 8 * mouseY;
				// camera.position.z  = 2 + 8 * mouseX;

				raycaster.setFromCamera(pointer, camera);

				const intersects = raycaster.intersectObject(screenMesh, false);
				const found = intersects[0];
				if (found) {
					var uv = found.uv
					stats.innerHTML += `${uv.x}, ${uv.y}`
				}

				camera.position.x += ((mouseX - 0.5) * 10 - camera.position.x) * .05;
				camera.position.y += (-(mouseY - 0.5) * 10 - camera.position.y) * .05;

				window.c = camera;
				camera.lookAt(screenMesh.position.x, screenMesh.position.y, screenMesh.position.z)

				if (started) {
					player.nextFrame();
					videoTexture.needsUpdate = true;
				}

				renderer.render(scene, camera);
			};


			animate();
		}




	</script>

</body>

</html>