<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl + jsmpeg</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			overflow: none;
			margin: 0;
		}
	</style>
</head>

<body>

	<div id="mesh" style="width:100px; height: 100px;  position: absolute;">
		<div id="stats"></div>
	</div>
	<script type="text/javascript" src="vendor/jsmpeg/jsmpeg.min.js"></script>

	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

	<script type="importmap">
			{
				"imports": {
					"three": "/gits/three.js/build/three.module.js"
				}
			}
		</script>

	<script src="src/wire.js"></script>
	<script src="src/connection.js"></script>
	<script src="src/transmitter.js"></script>
	<!-- <script src="src/transmitter_example.js"></script> -->
	<script type="text/javascript">
		var target = 'wss://' + location.hostname + '/touch/touchpad';
		var connection = new Connection(target, handler);
		connection.open();

		// activateTouch();

		var scale = '.75';
		var mode = 'sr';

		function screenshare() {
			mode = 'sr';
			resizeStream();
		}

		function resizeStream() {
			connection.sendType(mode, {
				scale: scale
			});

			// TODO server should broadcast request to resize
			setTimeout(() => {
				player.video.hasSequenceHeader = false
			}, 500);
		}

		function webcam() {
			mode = 'wr';
			resizeStream();
		}

		function setScale(s) {
			scale = s;
			resizeStream();
		}

		function ask() {
			var input = prompt('Say something');
			if (input) connection.sendType('rt', {
				text: input
			})
		}

		function activate(target) {
			target.addEventListener('keydown', (e) => {
				console.log('down', e);
				connection.send('key: ' + e.key + ' code: ' + e.code);
			});

			target.addEventListener('keyup', (e) => {
				console.log('up', e);
			});
		}
	</script>


	<script type="module">
		// var url = 'ws://' + document.location.hostname + ':8082/';
		var url = 'wss://' + document.location.hostname + '/screenshare';
		var started;
		var videoCanvas = document.createElement('canvas');

		var player = new JSMpeg.Player(url, {
			canvas: videoCanvas,
			disableWebAssembly: false,
			audio: false,
			onVideoDecode: function (decoder, elapsedTime) {
				stats.innerHTML = `${(elapsedTime * 1000).toFixed(2)}ms / ${(1 / elapsedTime).toFixed(0)} fps`;

				if (!started) {
					console.log(decoder, videoCanvas.width, videoCanvas.height);
					player.pause();
					started = true;
					init();
					// screenMesh.scale.x = videoCanvas.width / videoCanvas.height;
				}
			},
			// preserveDrawingBuffer: true,
		});
		window.player = player;


		import * as THREE from 'three';

		import { VRButton } from '/gits/three.js/examples/jsm/webxr/VRButton.js';
		import { ParametricGeometry } from '/gits/three.js/examples/jsm/geometries/ParametricGeometry.js';
		import { ParametricGeometries } from '/gits/three.js/examples/jsm/geometries/ParametricGeometries.js';
		import { HTMLMesh } from '/gits/three.js/examples/jsm/interactive/HTMLMesh.js';

		import Stats from '/gits/three.js/examples/jsm/libs/stats.module.js';

		import { InteractiveGroup } from '/gits/three.js/examples/jsm/interactive/InteractiveGroup.js';
		import { XRControllerModelFactory } from '/gits/three.js/examples/jsm/webxr/XRControllerModelFactory.js';
		import { GUI } from '/gits/three.js/examples/jsm/libs/lil-gui.module.min.js';

		var cube, videoTexture, raycaster;
		const pointer = new THREE.Vector2();

		function init() {
			const scene = new THREE.Scene();
			// scene.background = new THREE.Color(0xdddddd)
			scene.background = new THREE.Color(0x333333)
			// scene.fog = new THREE.FogExp2( 0x333333, 0.0025 );
			const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
			camera.position.set(0, 1.6, 1.5);

			var object3d = new THREE.AmbientLight(0x101010)
			object3d.name = 'Ambient light'
			// object3d.castShadow = true;
			scene.add(object3d)

			var object3d = new THREE.DirectionalLight('white', 0.225)
			object3d.position.set(2.6, 1, 3)
			object3d.position.multiplyScalar(10);
			object3d.name = 'Back light'
			object3d.castShadow = true;
			scene.add(object3d)


			var object3d = new THREE.DirectionalLight('white', 0.375)
			object3d.position.set(-2, -1, 0)
			object3d.position.multiplyScalar(10);
			object3d.name = 'Key light'
			object3d.castShadow = true;
			scene.add(object3d)

			var object3d = new THREE.DirectionalLight('white', 0.75)
			object3d.position.set(3, 3, 2)
			object3d.position.multiplyScalar(10);
			object3d.name = 'Fill light'
			object3d.castShadow = true;
			scene.add(object3d)


			var raycaster = new THREE.Raycaster();
			const renderer = new THREE.WebGLRenderer();
			renderer.xr.enabled = true;

			// renderer.shadowMap.enabled = true;

			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setPixelRatio(window.devicePixelRatio);
			document.body.appendChild(renderer.domElement);

			document.body.appendChild(VRButton.createButton(renderer));

			// const geometry = new THREE.BoxGeometry();
			// const material = new THREE.MeshLambertMaterial({color: 0x44aa88});
			// cube = new THREE.Mesh( geometry, material );
			// scene.add( cube );


			var groundMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
			groundMaterial.color.setHSL(0.6, 0.1, 0.7);
			var plane = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), groundMaterial);
			plane.position.y = - 2;
			plane.rotation.x = - Math.PI / 2;
			plane.receiveShadow = true;
			scene.add(plane);

			// const screenGeometry = new THREE.PlaneGeometry( 1, 1 );

			function curveFunction(u, v, target) {
				const x = u * 1;
				const y = v * 1;

				// could use spline curve here too
				// const z = Math.sin(-u * Math.PI) * 0.2;
				// normalize  between  -0.4, 0.4
				const z = ((u - 0.5)) ** 2 * 0.4;
				// flat
				// const z  = 0;

				target.set(x, y, z);
			}

			var screenGeometry = new ParametricGeometry(curveFunction, 20, 1);

			screenGeometry.center();

			videoTexture = new THREE.CanvasTexture(videoCanvas);
			const materialCanvas = new THREE.MeshBasicMaterial({
				// wireframe: true,
				// color: 0xffffff,
				// doubleSided
				map: videoTexture
			});

			const screenMesh = new THREE.Mesh(screenGeometry, materialCanvas);
			window.screenMesh = screenMesh;
			screenMesh.scale.x = videoCanvas.width / videoCanvas.height;
			screenMesh.scale.multiplyScalar(2);
			// screenMesh.rotation.x = -Math.PI / 6;
			screenMesh.castShadow = true;
			screenMesh.position.set(0, 1.6, -0.8);

			scene.add(screenMesh)

			var mouseX = 0.5, mouseY = 0.5;
			window.addEventListener('mousemove', (e) => {
				mouseX = e.clientX / innerWidth;
				mouseY = e.clientY / innerHeight;

				pointer.set(mouseX - 0.5, mouseY - 0.5)
			})


			//

			const geometry = new THREE.BufferGeometry();
			geometry.setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, - 5)]);

			const controller1 = renderer.xr.getController(0);
			controller1.add(new THREE.Line(geometry));
			scene.add(controller1);

			const controller2 = renderer.xr.getController(1);
			controller2.add(new THREE.Line(geometry));
			scene.add(controller2);

			//

			const controllerModelFactory = new XRControllerModelFactory();

			const controllerGrip1 = renderer.xr.getControllerGrip(0);
			controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
			scene.add(controllerGrip1);

			const controllerGrip2 = renderer.xr.getControllerGrip(1);
			controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
			scene.add(controllerGrip2);

			const group = new InteractiveGroup(renderer, camera);
			scene.add(group);

			// const mesh = new HTMLMesh( document.getElementById('mesh') );
			// mesh.position.x = - 0.75;
			// mesh.position.y = 1.5;
			// mesh.position.z = - 0.5;
			// mesh.rotation.y = Math.PI / 4;
			// mesh.scale.setScalar( 2 );
			// scene.add( mesh );

			var stats = new Stats();
			// stats.dom.style.width = '80px';
			// stats.dom.style.height = '48px';
			document.body.appendChild(stats.dom);

			window.statsMesh = new HTMLMesh(stats.dom);
			statsMesh.position.x = - 1.25;
			statsMesh.position.y = 2;
			statsMesh.position.z = - 0.6;
			statsMesh.rotation.y = Math.PI / 4;
			statsMesh.scale.setScalar(2.5);
			group.add(statsMesh);

			const parameters = {
				scale: 1.5,
				x: 0,
				y: 1.4,
				z: -0.65,
			};
			const gui = new GUI({ width: 300 });
			gui.add(parameters, 'scale', 0.5, 10.0);
			gui.add(parameters, 'x', -10.0, 10.0);
			gui.add(parameters, 'y', -10.0, 10.0);
			gui.add(parameters, 'z', -10.0, 10.0);

			// gui.domElement.style.visibility = 'hidden';


			const mesh = new HTMLMesh(gui.domElement);
			mesh.position.x = 1.45;
			mesh.position.y = 1.5;
			mesh.position.z = - 0.5;
			mesh.rotation.y = -Math.PI / 4;
			mesh.scale.setScalar(2);
			group.add(mesh);


			function animate() {
				if (false) {
					// non  xr
					// screenMesh.rotation.x = (mouseY - 0.5) * 0.0;

					// camera.position.y  = -3.5 + 8 * mouseY;
					// camera.position.z  = 2 + 8 * mouseX;

					raycaster.setFromCamera(pointer, camera);

					const intersects = raycaster.intersectObject(screenMesh, false);
					const found = intersects[0];
					if (found) {
						var uv = found.uv
						stats.innerHTML += `${uv.x}, ${uv.y}`
					}

					// camera.position.x += ((mouseX - 0.5) * 10 - camera.position.x) * .05;
					// camera.position.y += (-(mouseY - 0.5) * 10 - camera.position.y) * .05;
					// camera.lookAt(screenMesh.position.x, screenMesh.position.y, screenMesh.position.z)
				}

				let { x, y, z, scale } = parameters;
				screenMesh.scale.set(scale * videoCanvas.width / videoCanvas.height, scale, scale);
				screenMesh.position.set(x, y, z);

				if (started) {
					player.nextFrame();
					videoTexture.needsUpdate = true;
				}

				stats.update();
				statsMesh.material.map.update();

				renderer.render(scene, camera);
			};

			renderer.setAnimationLoop(animate);

			// animate();
			// requestAnimationFrame(animate);
		}




	</script>

</body>

</html>